[TOC]

# 前言

1. 本笔记与书

   > 汇编语言程序设计/刘慧婷，王庆生主编.--2版.--北京：人民邮电出版社，2017.1

   配套

2. 自己根据考试重点总结的，不保证全，不保证对，以老师PPT和电子书为主，辅以自己的魔改
3. 表述注重简洁精炼，但是遇到重难点会不吝笔墨（吹）
4. 求大佬指正与完善Orz

# 第1章 汇编语言基础知识

## ASCII码

* 记牢几个常用的十六进制
* 理解回车换行（Carriage-Return Line-Feed）
  * 回车（13，0DH）（转义序列\r），将光标移动到当前行的开头（改变横坐标）
  * 换行（10，0AH）（转义序列\n），将光标移动到下一行的当前位置（改变纵坐标）
  * 深入理解：CR 代表“回车”——CR 控制字符将打印头（“回车”）返回到第 0 列，而无需推进纸张。 LF 代表“换行”——LF 控制字符在不移动打印头的情况下将纸张前进一行。因此，如果您想将打印头返回到第 0 列（准备打印下一行）并推进纸张（以便在新纸上打印），则需要 CR 和 LF。

![img](assets/1.jpeg)

![img](assets/2.jpeg)

## 计算机程序设计语言分类

1. 低级语言

  1. 机器语言（Machine Language）

     * 计算机硬件直接识别的程序设计语言。

     * 构成这种程序的是用二进制编码的机器指令，即编码中只含二进制0或1，由计算机直接记忆、传输、识别和加工。

     * 被称为第一代语言，复杂难记，依赖于具体的机型。程序编写难度极大，调试修改困难，可移植性差。

  2. 汇编语言（Assembly Language）
       * 一种面向机器的用**符号表示**的程序设计语言，也叫符号语言。
       * 和机器语言不同的是，汇编语言用直观、便于记忆和理解的英文单词或缩写符号（助记符）来表示指令和数据变量
       * 被称为第二代语言。

2. 高级语言（High Level Language）
   * 被称为第三代语言。

## 汇编语言由以下三类指令组成。

（1）汇编指令：机器码的助记符，有对应的机器码。

（2）伪指令：由编译器执行，没有对应的机器码。

（3）其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码。

## 汇编语言特点

1. 面向机器的低级语言，可移植性差
2. 程序效率高，执行速度快，内存占用小
3. 可以与高级语言配合使用（c/c++）
4. 调试困难
5. 语言直接、简洁

## 汇编程序与汇编源程序区别

汇编程序：特指将汇编源程序翻译成机器语言程序的编译程序。

汇编源程序：用用汇编语言编写的程序。

# 第2章 计算机基本原理

## 冯诺依曼原理的计算机结构

![](assets/image-20221103112541564.png)

## 8086/8088内部结构

![](assets/QQ截图20220907093415.jpg)

## 16位机的各类寄存器

### 通用数据寄存器： Ax , Bx , Cx , DX 

8086 CPU的所有寄存器都是16位的，可以存放两个字节。AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据，有时候也可以存放地址，被称为通用数据寄存器。

①AX：累加器，运算时使用这个寄存器较多，有些指令规定必须使用它。

②BX：基址寄存器，除了存放数据，它经常用来存放一段内存的起始偏移地址。

③CX：计数寄存器，除了存放数据，它经常用来存放重复操作的次数。

④DX：数据寄存器，除了存放数据，它有时存放32位数据的高16位。

### 地址寄存器

16位的8086处理器有4个16位的通用地址寄存器。它们的主要作用是存放数据的所在偏移地址，也可以存放数据。这4个寄存器不能再拆分使用。

①SP：堆栈指针，这是一个专用的寄存器，存放堆栈栈顶的偏移地址。

②BP：基址指针，可以用来存放内存中数据的偏移地址。

③SI：源变址寄存器，它经常用来存放内存中源数据区的偏移地址，所谓变址寄存器，是指在某些指令作用下它可以自动地递增或递减其中的值。

④DI：目的变址寄存器，它经常用来存放内存中目的数据区的偏移地址，并在某些指令作用下可以自动地递增或递减其中的值。

### 段寄存器

16位80x86处理器有4个16位的段寄存器，分别命名为CS，SS，DS，ES。它们用来存放4个段的段基址。 

①CS：代码段寄存器，用来存放当前正在执行的程序段的段基址。

②SS：堆栈段寄存器，用来存放堆栈段的段基址。

③DS：数据段寄存器，用来存放数据段段基址。

④ES：附加段寄存器，用来存放另一个数据段的段基址。 

### 专用寄存器

1. IP：指令指针寄存器，存放即将执行指令的偏移地址。

2. Flags 标志寄存器，又称程序状态寄存器。它是存放cpu标志的寄存器。

   * 状态标志：反映处理器当前的状态，如有无溢出，有无进位等。状态标志有6个：CF、PF、AF、ZF、SF和OF

     ![image-20221104155811108](assets/image-20221104155811108.png)
   
     1. OF：溢出标志。
        * 含义
          * OF=l表示两个有符号数的运算结果超出了可以表示的范围，结果是错误的；
          * OF=0表示没有溢出，结果正确。
        * 注意：进行无符号数运算时也会产生新的 OF 标志（CPU 不知道处理对象是否为有符号数），此时程序员可以不关心OF标志。
        * 公式：OF= $$c_{n} \oplus c_{n-1}$$ 
        * =1情况：正数相加得负数，或者负数相加得正数，或者正数减负数得负数，或者负数减正数得正数。
     2. DF：方向标志。DF=0时，每次执行字符串指令后，源或目的地址指针用**加法**自动修改地址；DF=l时用**减法**来修改地址。它用来控制地址的变化方向。
     3. IF：中断允许标志。IF=l 表示允许处理器响应可屏蔽中断请求信号，称为开中断，IF=0表示不允许处理器响应可屏蔽中断请求信号，称为关中断。
     4. SF：符号标志。
        * 含义：SF=1表示**运算结果的最高位**为“1”。对于有符号数，在溢出标志 OF=0时，SF=1表示运算结果为负，SF=0表示运算结果非负（正或零）。
        * 注意：OF=1时，由于结果是错误的，所以符号位也和正确值相反。例如，两个负数相加产生溢出（变成正数），此时SF=0。对于无符号数运算，SF无意义（但是可以看出结果的大小规模）。
     5. ZF：零标志。ZF=l表示运算结果为零，减法运算后结果为零意味着两个参加运算的数大小相等；ZF=0，表示运算结果非零。
     6. AF：辅助进位标志。在进行字操作时，低字节向高字节进位时，AF=1，否则为0。一般用于两个BCD数运算后调整结果用，对其他数的运算没有意义。
     7. PF：奇偶标志。**PF=1**表示运算结果的低8位中有**偶数**个“1”;**PF=0**表示有**奇数**个“1”（记忆方法：PF和运算结果的低8位中总共"1"的个数恒为**奇数个**）。它可以用来进行**奇偶校验**。
     8. CF：进位/借位标志。
        * 含义：CF=1表示两个无符号数的加法运算有进位，或者是减法运算有借位，需要对它们的高位进行补充处理；CF=0表示没有产生进位或借位。同样，进行有符号数运算时也会产生新的CF标志，此时程序员可以不关心CF标志。
        * 公式：CF= $$c_n$$ ，最高位是否有进位。
     * 共同点：状态标志在每次运算后自动产生，控制标志的值则由指令设置。
   
   * 控制标志：用来控制处理器的工作方式，如是否响应可屏蔽中断等。控制标志有3个：TF、IF和DF（串传送方向标志）

## 溢出标志 OF 与进位标志 CF 有何作用和区别？

答，处理器对两个操作数进行运算时，按照无符号数求得结果，并相应设置进标志 CF ;同时，根据是否超出有符号数的范围设置溢出标志OF。应该利用哪标志，则由程序员来决定。也就是说，如果将参加运算的操作数认为是无符号数应该关心进位；认为是有符号数，则要注意是否溢出。

## 8086 CPU的工作过程简要描述

（1）从CS:IP指向的内存单元读取指令，读取的指令进入**指令队列缓冲器**；

（2）IP=IP+所读取指令的长度，从而指向下一条指令；

（3）执行指令，转到步骤（1），重复这个过程。

# 第3章 汇编语言程序实例及上机操作

## 汇编语言源程序的建立到产生可执行文件的步骤和上机操作命令。

1. 用编辑程序 EDIT.COM /记事本 建立．ASM 源文件

2. 用汇编程序 MASM.EXE 把． ASM 文件原文件汇编成．0BJ文件

3. 用连接程序 LINK.EXE 将． OBJ 文件转换成． EXE 文件

4. 在 DOS 下直接运行． EXE 文件或在 DEBUG 下调试该． EXE 可执行文件。

   ![image-20221103155113669](assets/image-20221103155113669.png)

## 程序中用什么语句来结束程序的执行？用什么语句来表示程序的结束和指出程序执行的起点？

答：程序的结束： 
mov ah , 4cH
int 21h
程序的结束和指出执行的起点： End start(标号不固定)

## 简述在WIN7系统中执行汇编的方法。

下载安装 DosBox ，运行该程序，出现 DosBox 运行界面，运行挂载命令 mount ,即可以将 Dos 程序放置在 Windows 环境下 Dos 模拟器中运行，其过程为挂载。

## debug命令

1. R命令
   查看、改变CPU寄存器的内容。
2. D命令
   查看内存中的内容。
3. E命令
   改写内存中的内容
4. 反汇编命令U
   把机器语言反汇编为汇编语言，便于用户看程序。命令格式为U[偏移地址]或U[段地址]:[偏移地址] [要查看多少字节的指令]。方括号表示可选。=表示不能省掉。
5. 运行程序命令G
   G命令用于执行程序，命令格式为G[=起始地址] [中止地址]。其中[中止地址]是为了给程序设置断点，让程序暂停在某个位置，便于观测。若不设置终止地址则直接执行到程序结束。若省掉起始地址，则以当前CS：IP作为起始地址。
6. 跟踪程序命令T
   类似于step into，用于单步执行程序，所以又叫跟踪程序。命令格式为T[=起始地址] [指令条数]。可以控制程序每执行一条指令就暂停，并显示当前机器情况。
   * 特别指出：对于INT指令不能使用T命令跟踪。因为INT指令实质上是调用一个系统中断程序，T命令使程序进入了中断程序内部命令
7. 单步执行程序命令P
   类似于step over，P命令用以执行loop**循环**、**重复的字符串指令**、软件**中断**或**子例程**(子程序)。例如T命令无法一次执行的INT指令，P命令就可以一次执行完这个系统例行程序，回到用户程序中。
8. 退出命令Q
   用Q命令退出Debug。

## DOS 系统功能 INT 21H调用方法。

(1）将调用功能的功能号存入 AH 寄存器。
(2）如必要，设置该调用功能的入口参数。
(3）执行 INT 21H指令。
(4）如必要，按规定取得出口参数（返回参数）。

## 21H号中断

是DOS提供给用户的用于调用系统功能的中断，它有近百个功能供用户选择使用，主要包括设备管理、目录管理和文件管理三个方面的功能。

|  AH  |        功能        |                          调用参数                           |                           返回参数                           |
| :--: | :----------------: | :---------------------------------------------------------: | :----------------------------------------------------------: |
|  01  |   键盘输入并回显   |                                                             |                         AL=输入字符                          |
|  02  |      显示输出      |                         DL=输出字符                         |                                                              |
|  07  | 键盘输入（无回显） |                                                             |                         AL=输入字符                          |
|  09  |     显示字符串     |              DS:DX=串地址，<br/>字符串以\$结尾              |                                                              |
|  0A  |  键盘输入到缓冲区  | DS:DX=缓冲区首地址(DS:DX)=缓冲区最大字符数<br/>（包括了\$） | (DS:DX+1)=实际输入的字符数（至少比最大字符数小1）；<br/>从(DS:DX+2)开始为输入的字符串，不会自动在末尾补上\$ |

##  Debug 命令调试含有“ INT 21H”命令的程序段时如何实现单步执行，“- t ”命令为何无法实现？

“ INT 2TH描令是 Dos 的系统调用，加果使用“ t ”银踪，则进人DOS子程序。如果希望单步执行，可以通过 P 命令来实现。

## 何为段地址？何为有效地址？何为物理地址？

例如 DS =6542，指令 mov ax , DS :[123A]:123A为有效地址，6542H为段地址,65420H+0123A=6665A即物理地址

## CMP 和 TEST 指令与其他指令的不同之处在于什么？它们通常都紧跟着跳转指令，用在什么场合？

答， CMP 和 TEST指令分别执行减法和逻辑与操作，但不回送结果，只影响标志位，通常用于判断两个数的大小或者用于判断操作数的某些位是1或0。


# 第4章 操作数的寻址方式

## 寻址方式定义

* 指令中寻找操作数的方式。

## 寻址方式分类

### 立即寻址方式

* 定义
  * 操作数（立即数）就在指令中，紧跟在操作码之后，操作数作为指令的一部分存放在代码段。
* 举例
  * MOV AL, 6H
* 注意
  * 执行时无需去内存取数，因此称为立即数。
  * 主要用于寄存器赋初值。
  * 立即数只能作为源操作数，并且长度与目的操作数一致。

###**寄存器寻址方式** 

* 定义
  * 操作数就是寄存器中的值。指令中给出寄存器名。
* 举例
  * MOV AX,BX
* 注意
  * 以上两种寻址方式都与主存储器无关。
  * 以下介绍的各种寻址方式的操作数都在主存储器中。
  * 偏移地址也称为有效地址（EA）。


### 直接寻址方式

* 定义

  * 操作数的有效地址EA就在指令中（变量/常量/立即数），默认段地址=(DS)。

* 举例

  1. 存储器读操作
     例4-4 MOV AX, DS: [2000H]
     该指令表示从数据段的2000H单元读出一个字送入AX。
     其中(DS)=1500H, (17000H)=31H, (17001H)=65H, (AX)=1020H。
     则有效地址EA=2000H
     物理地址=(DS)*10H+EA=15000H+2000H=17000H
     执行指令后：(AX)=6531H

  2. 存储器写操作
     例4-5  MOV DS: [4000H], AX
     将AX的值写入数据段的4000H单元。已知(DS)=1500H, (AX)=3946H。
     则有效地址EA=4000H
     物理地址 =(DS)*10H+EA
     =15000H+4000H=19000H
     执行指令后：(19000H)=46H，(19001H)=39H
     
  3. 符号地址
    
     直接寻址方式除了用数值作为有效地址之外，还可以用符号地址的形式。为存储单元定义一个名字，该名字就是符号地址。如果把存储单元看成变量，该名字也是变量名。
     
     例4-6
     VALUE DW 5678H
     MOV AX,VALUE
     MOV AX,[VALUE]
     该指令表示从数据段的 VALUE 单元读出数据5678H送入 AX 。
     有效地址 EA = VALUE =1000H
     物理地址=( DS )x10H+ EA =15000H+1000H=16000H
     若(16000H)=5678H执行指令后：( AX )=5678H
     
  3. 段前缀
    
    在与内存有关的寻址方式中，操作数的段地址默认为数据段，80X86规定除了数据段之外，数据还可以存放在其他三种段(CS,SS,ES)中。如果操作数在其他段中存放，称为段超越，需要在指令中用段超越前缀(CS:,SS:,ES:)指出，即用操作数前加上段寄存器名和冒号表示。
    
    例4-7 
    VALUE EQU 1000H
    MOV AX, DS: [VALUE]
    MOV AX, ES: [VALUE]
    若已知(ES)=3600H，EA=VALUE=1000H，
    则有段超越前缀ES的指令源操作数的物理地址计算为：
    物理地址=(ES)\*10H+EA=36000H+1000H=37000H
    若字单元(37000H)=9091H
    执行完MOV AX, ES: [VALUE]后：(AX)=9091H


###寄存器间接寻址方式

* 定义
  * 操作数的有效地址在特定的寄存器中。
* 举例
  1. 例4-8 MOV AX,[BX]
     已知（DS）=1500H，（BX）=4580H，则
     EA=（BX）=4580H
     物理地址=（DS）\*10H+EA=15000H+4580H=19580H
     若（19580H）=2364H
     执行指令后：（AX）=2364H
  2. 例4-9 MOV SS:[DI],AX
     已知（SS）=2500H，（DI）=5318H，则
     EA=（DI）=5318H
     物理地址=（SS）\*10H+EA=25000H+5318H=2A318H
     若（AX）=2468H
     执行指令后：（2A318H）=68H
     （2A319H）=24H
* 注意
  * 只允许使用BX、S、DI和BP寄存器。
    * 物理地址=10H x (DS) + (BX)：MOV AX,[BX]
    * 物理地址=10H x (DS) + (SI)：MOV AX,[SI]
    * 物理地址=10H x (DS) + (DI )：MOV AX,[DI]
    * 物理地址=10H x (SS) + (BP)：MOV AX,[BP]
      * 无需段超越前缀，因为BP默认与SS搭配

###寄存器相对寻址方式

* 定义
  * 操作数的有效地址是一个**寄存器**和**位移量**（变量/常量/立即数）之和。

* 举例
  1. 例4-13
     MOV  AX，ARRY[BX]
     MOV  AX，[ARRY] [BX]
     MOV  AX，[ARRY+BX]
     MOV  AL，BUF[BX]
     MOV  AL，[BX+8H]
     MOV  AL，[BX].8H
  2. 例4-11 MOV AX, TOP[SI]
     以上指令TOP为符号地址，即位移量。
     已知（DS）=1500H，（SI）=7310H，TOP=25H，则
     有效地址EA=（SI）+TOP=7310H+25H=7335H
     物理地址=（DS）\*10H+EA=15000H+7335H=1C335H
     若（1C335H）=2428H，执行指令后，（AX）=2428H
* 注意
  * 只允许使用BX、S、DI和BP寄存器。
    * 物理地址=10H x (DS) + (BX) + 8(16)位位移量：MOV AX,[BX+00H]
    * 物理地址=10H x (DS) + (SI) + 8(16)位位移量：MOV AX,[SI+0000H]
    * 物理地址=10H x (DS) + (DI) + 8(16)位位移量：MOV AX,[DI+0000H]
    * 物理地址=10H x (SS) + (BP) + 8(16)位位移量：MOV AX,[BP+00H]
      * 无需段超越前缀，因为BP默认与SS搭配

###基址变址寻址方式

* 定义
  * 操作数的有效地址是一个**基址寄存器**和一个**变址寄存器**的内容之和。
* 举例
  1. 例4-14 MOV AX, [BX+DI]
     执行前：已知（DS）=2100H，（BX）=0158H，（DI）=10A5H，（221FD）=34H，（221FE）=95H，（AX）=0FFFFH。则
     有效地址EA=（BX）+（DI）=0158H+10A5H=11FDH
     物理地址=（DS）\*10H+EA=21000H+11FDH=221FDH
     执行后，（AX）=9534H
  2. 例4-15
     MOV  AX，[BX] [SI]         ；默认DS寄存器作段地址
     MOV  AX，[BP] [DI]         ；默认SS寄存器作段地址
     MOV  AX，ES:[BX] [DI]   ；指定ES寄存器作段地址
     MOV  DX，[BP] [SI]		；默认SS寄存器作段地址
     MOV  [BX+DI], CX		；默认DS寄存器作段地址
     MOV  [BP+SI], AL		；默认SS寄存器作段地址
* 注意
  * 允许使用的基址寄存器BX和BP，变址寄存器SI和DI。
    * 物理地址=10H x (DS) + (BX) + (DI)：MOV AX,[BX+DI]
    * 物理地址=10H x (DS) + (BX) + (SI)：MOV AX,[BX+SI]
    * 物理地址=10H x (SS) + (BP) + (SI)：MOV AX,[BP+SI]
    * 物理地址=10H x (SS) + (BP) + (DI)：MOV AX,[BP+DI]


###相对基址变址寻址方式 

* 定义
  * 操作数的有效地址是一个基址寄存器和一个变址寄存器以及一个位移量（变量/常量/立即数）之和。

* 举例
  1. 例4-16
     MOV  AX，MASK[BX] [SI]      ；默认DS寄存器作段地址
     MOV  AX，[MASK+BX+SI]	；默认DS寄存器作段地址
     MOV  AX，[BX+SI].MASK	；默认DS寄存器作段地址
     以上三种表示形式实现的功能是一样的。其有效地址EA=MASK+(BX)+(SI)；
     物理地址=(DS)*10H+EA。
* 注意
  * 允许使用的基址寄存器BX和BP，变址寄存器SI和DI。
    * 物理地址=10H x (DS) + (BX) + (DI) + 8(16)位位移量：MOV AX,[BX+DI+00H]
    * 物理地址=10H x (DS) + (BX) + (SI) + 8(16)位位移量：MOV AX,[BX+SI+0000H]
    * 物理地址=10H x (SS) + (BP) + (SI) + 8(16)位位移量：MOV AX,[BP+SI+0000H]
    * 物理地址=10H x (SS) + (BP) + (DI) + 8(16)位位移量：MOV AX,[BP+DI+00H]

# 第5章 常用指令

## 80x86汇编语言指令语句的一般格式

*  [标号:]  指令助记符  [操作数]  [;注释] （[ ]中的内容可选）
   * 标号：指令的符号地址，表示指令在内存中的位置。标号后应加冒号：。
   * 指令助记符/操作码：指令名称，是指令功能的英文缩写。
   * 操作数：指令要操作的数据或数据所在的地址。寄存器，常量，变量，表达式。
   * 注释：每行以分号“；”开头，汇编程序不处理。

## 数据传送指令

### 通用数据传送指令

* 数据传送方向

  ![image-20221103195925887](assets/image-20221103195925887.png)

* MOV                     传送

  * 格式: MOV  DST,  SRC
  * 操作: (DST)←(SRC)
    * DST 表示目的操作数, SRC 表示源操作数。

  * 功能：将源操作数传送到目的操作数。
  * 注意
    * 源操作数与目的操作数的长度必须一致。
    * 源操作数与目的操作数不能同时为存储器。
    * 目的操作数不能为CS和IP，因为CS：IP是程序当前地址。
    * 目的操作数不可以是立即数。
  * 举例
    1. 例5.1立即数与寄存器的传送
       MOV  AH, 89	        ；十进制数
       MOV  AX, 2016H        ；十六进制数，后面加H
       MOV  AX, 0ABCDH	；十六进制数，因非数字(0～9)开头，前面加0，避免被误认为标号或变量
       MOV  AL, 10001011B	 ；二进制数，后面加B，一个字节以内
       MOV  AL, ‘A’        ；字符‘A’的ASCII码是41H，相当于立即数
    2. MOV  BL, OFFSET  TABLE ;错误，不管变量类型如何，其有效地址总是16位。

* PUSH                   进栈

  * 格式: PUSH   SRC
  * 操作
    * (SP)←(SP)-2
    * (( SP)+1,(SP))←(SRC) 

  * 功能：后进先出内存区，以字为单位传送，SS:SP总是指向栈顶。


![img](assets/epub_34538823_96.jpeg)

* POP                      出栈
  * 格式: POP   DST
  * 操作
    * (DST)←((SP)+1,(SP))
    *  (SP)←(SP)+2 

* XCHG                   交换
  * 格式: XCHG   OPR1,  OPR2
  * 操作: (OPR1) ↔(OPR2)
  * 功能：把两个操作数互换位置。
  * 注意：遵循双操作数指令的规定，但操作数不能为立即数。

### 累加器专用传送指令（估计不考）

* 其中I/O端口是CPU 与外设传送数据的接口,单独编址,不属于内存,端口地址范围0000~FFFFH.这组指令只限于AX,AL累加器。
* IN        		 ;从I/O端口输入
* OUT     		;向I/O端口输出
* XLAT(translate)   ;换码 （查表）

### 地址传送指令

* LEA（Load Effective Address）           有效地址送寄存器
  * 格式：LEA  REG,SRC
  * 操作：REG←SRC
  * 功能：把源操作数的有效地址EA送到指定的寄存器。
  * 举例
    1. 例5.13   取变量的有效地址
       LEA   BX， TABLE
       MOV   BX， OFFSET TABLE
       上面2条指令等效。TABLE无论是何类型的变量，其有效地址总是16位。
       
    2. 例5.14 
       LEA   BX， [2016H]
       MOV  BX,  OFFSET  [2016H]
       指令执行后，BX=2016H。
* LDS（Load DS with Pointer）            指针送寄存器和DS
  * 格式： LDS   REG, SRC
  * 操作
    * REG←（SRC）
    * DS←（SRC+2）

  * 功能：把源操作数SRC所指向的内存单元中的两个字送到指定的寄存器REG和DS。
  * 举例
    1. 例5.15 
       LDS   SI， [BX]
       指令执行前，如DS=2000H，BX=0400H，(2000:0400)=1234H, (2000:0402)=5678H,
       指令执行后，SI=1234H，DS=5678H。
* LES（Load ES with Pointer）            指针送寄存器和ES
  * 格式： LES   REG, SRC
  * 操作
    * REG←（SRC）
    * ES←（SRC+2）

  * 功能：把源操作数SRC所指向的内存单元中的两个字送到指定的寄存器REG和ES。
  * 举例
    1. 例如 LES   DI,  [10H] 
       DS=C000H,  (C0010H)=0180H,    (C0012H)=2000H
       结果 DI=0180H,  ES=2000H 

### 标志寄存器传送（估计不考）

## 算术运算指令

### 类型扩展指令

* CBW
  * 功能：AL扩展为AX
* CWD
  * 功能：AX扩展为DX，AX
* 举例
  1. 例5.17   正数的扩展
     MOV  AL，52H  ；AL中的52H是正数
     CBW                   ；指令执行后，AX=0052H
     CWD                   ；指令执行后，DX=0000H，AX=0052H
  2. 例5.18   负数的扩展
     MOV  AL，88H   ；AL中的88H是负数
     CBW                    ；指令执行后，AX=FF88H
     CWD                    ；指令执行后，DX=FFFFH，AX=FF88H

### 加法指令

* ADD               加法
  * 格式：ADD   DST，SRC 
  * 操作：（DST）← （DST） + （SRC）
  * 举例
    1. 例5.19  无符号数的溢出标志位CF
       MOV   AL，72H
       ADD   AL，93H
       105H，超出8位表示范围，丢失256。(AL)=05H
* ADC               带进位加法
  * 格式：ADC   DST，SRC 
  * 操作：（DST）←（DST）+（SRC）+CF
  * 举例
    1. 例5.21  用16位指令实现32位的双精度数的加法运算。设数A存放在目的操作数寄存器DX和AX，其中DX存放高位字。数B存放在寄存器BX和CX，其中BX存放高位字。如：
       DX=2000H， AX=8000H
       BX=4000H， CX=9000H
       指令序列为：
       ADD   AX，  CX           ；低位字加
       ADC   DX，  BX           ；高位字加
       第一条指令执行后，AX=1000H，CF=1，OF=1，此处OF=1不必在意。 
       第二条指令执行后，DX=6001H，CF=0，OF=0，表示结果正常，无溢出。
* INC                 加1
  * 格式：INC   OPR 
  * 操作：（OPR）←（OPR）+1

* 除 INC 不影响CF，它们都影响条件标志位。

### 减法指令

* SUB             减法
  * 格式：SUB   DST，SRC 
  * 操作：（DST）← （DST） -（SRC）
* SBB             带借位减法
  * 格式：SBB   DST，SRC 
  * 操作：（DST）← （DST） -（SRC）-CF
  * 举例
    1. 例5.23  用16位指令实现32位的双精度数的减法运算。设数A存放在目的操作数寄存器DX和AX，其中DX存放高位字。数B存放在寄存器BX和CX，其中BX存放高位字。如：
       DX=2001H， AX=8000H
       BX=2000H， CX=9000H
       指令序列为：
       SUB   AX，  CX           ；低位字减法
       SBB   DX，  BX           ；高位字减法
       第一条指令执行后，AX=F000H，CF=1，而对OF=0，ZF=0,SF=1，不必在意。
       第二条指令执行后，DX=0000H，CF=0，OF=0，表示结果正确。ZF=1,SF=0。
* DEC             减1
  * 格式：DEC   OPR 
  * 操作：（OPR）←（OPR）-1
* NEG            求补
  * 格式：NEG   OPR 
  * 操作：（OPR）←-（OPR）
  * 功能：对OPR求补,求- OPR, 即反码+1。
  * 注意：只有OPR为0时，CF=0。
  * 举例
    1. 例5.24   考察NEG指令
       MOV   AX，  3
       NEG   AX
       MOV   DX，  0
       NEG   DX
       指令序列执行后，AX=FFFDH=－3(补码)，DX=0H。
       可以看出，NEG指令实际上就是求数X的相反数，即 求0－X，只有当X=0时，CF=0，其它情况CF=1。
* CMP            比较
  * 格式：CMP   OPR1, OPR2 
  * 操作：（OPR1）-（OPR2）
  * 注意：不回送结果，只产生标志位。
  * 举例
    1. 例5.25   考察CMP指令
       MOV   AX，  5
       DEC   AX
       CMP   AX，  5 ;0100-0101=1 1111
       指令序列执行后，AX=4，ZF=0，SF=1，CF=1，OF=0。
       CMP指令虽作减法，但不回送结果，只是产生标志位，为程序员比较两个数的大小提供判断依据。

### 乘法指令

* MUL     无符号数乘法
  * 格式：MUL   SRC
  * 操作
    * 操作数为字节时: (AX)← (AL) X (SRC) 
    * 操作数为字时: (DX,AX)← (AX) X (SRC) 
  
* IMUL    有符号数乘法 
  * 格式：IMUL   SRC
  * 操作
    * 操作数为字节时: (AX)← (AL) X (SRC) 
    * 操作数为字时: (DX,AX)← (AX) X (SRC) 
  
* 注意
  * 两个相乘的数必须长度相同，因为会根据SRC的长度选择寄存器。
  * SRC不能是立即数，因为长度不确定。
  
* 举例
  1. 例5.26   无符号数和带符号数的乘法
     MOV   AL，  0F1H
     MOV   BL，  AL
     MUL   BL ;15*16+1=241，241^2=58081
     指令序列执行后，AX=E2E1H。
     如果看成是两个带符号相乘，则应选择如下指令：
     MOV   AL，  0F1H
     MOV   BL，  AL
     IMUL  BL ;0F1H=1111 0001B，0-1111 0001=0000 1111=15， 15^2=225
     指令序列执行后，AX=00E1H。说明了两个负数相乘，结果为正数。
  
* DIV     无符号数除法
   * 格式：DIV SRC
      * 字节操作
         * (AL)←(AX)/(SRC)的商
         * (AH)←(AX)/(SRC)的余数

      * 字操作
         * (AX)←(DX,AX)/(SRC)的商
         * (DX)←(DX,AX)/(SRC)的余数

* IDIV    有符号数除法
   * 格式：IDIV SRC
      * 字节操作
        * (AL)←(AX)/(SRC)的商
        * (AH)←(AX)/(SRC)的余数
      * 字操作
        * (AX)←(DX,AX)/(SRC)的商
        * (DX)←(DX,AX)/(SRC)的余数
      * 注意
        * 余数和被除数同符号。
        * 商的符号是两个操作数符号的异或。

* 注意
  * 被除数长度应为除数长度的两倍。
  * SRC不能是立即数。
  * 当除数是字节类型时，除法指令要求商为8位。此时如果被除数的高8位绝对值≥除数的绝对值，则商会产生溢出。e.g.：11 0000 1000 /3=01 0000 0010余2，结果大于8位，产生溢出。
  * 当除数是字类型时，除法指令要求商为16位。此时如果被除数的高16位绝对值≥除数的绝对值，则商会产生溢出。
  * 商出现溢出时，系统转0号类型中断处理，提示“divide overflow”，并退出程序，返回到操作系统，程序已经崩溃了。要想避免出现这种情况，必须在作除法前对溢出作出预判。

* 举例
  1. 例5.27    作(字节)除法300H/2H，商产生溢出
     MOV  AX，  300H
     MOV  BL，  2
     DIV  BL
     此时被除数的高8位(AH=3)绝对值＞除数的绝对值2, 则商会产生溢出。实际上换成十进制计算也可说明商会产生溢出：300H/2H=768/2=384>255，显然，8位的AL寄存器容不下商384。 
     
  2. 例5.28   作(字)除法300H/2H，商不会产生溢出
     MOV  AX，  300H
     CWD ;(DX)=0000H，(AX)=0300H
     MOV  BX，  2
     DIV  BX
     此时被除数的高16位(DX=0), 则商不会产生溢出。显然AX寄存器完全能容下商384。
     
  3. 例5.29   算术运算综合举例，计算:(V－(X×Y＋Z－16))／X，其中X、Y、Z、V均为16位带符号数，在数据段定义，要求上式计算结果的商存入AX，余数存入DX寄存器。
  
     ```assembly
     data   segment
     	x  dw  4
     	y  dw  2
     	z  dw  14H
     	v  dw  18H
     data   ends
     
     code   segment
     assume  cs:code,ds:data
     start:
     	mov    ax,data
     	mov    ds,ax
     	mov    ax,x
     	imul   y             ;x×y 
     	mov    cx,ax         ;暂存(x×y)的结果 
     	mov    bx,dx
     	mov    ax,z         
     	cwd                  ;z符号扩展，等于mov dx,0
     	add    cx,ax         ;加z 
     	adc    bx,dx
     	sub    cx,16         ;减16
     	sbb    bx,0
     	mov    ax,v
     	cwd                  ;v符号扩展
     	sub    ax,cx         ;v减(x×y)的结果
     	sbb    dx,bx         ;V－(X×Y＋Z－16)=12
     	idiv   x	         ;12/4=3，未溢出
     	mov    ah,4ch
     	int    21h
         code   ends
     end  start
     ```
  

### BCD码的十进制调整指令（估计不考）

* 为便于十进制计算,计算机提供了十进制调整指令,在二进制数计算的基础上,给予十进制调整,直接得到十进制结果。 

## 逻辑指令与移位指令

### 逻辑指令

* 相同点：均按位操作,至少一个操作数是寄存器。
* AND     ;与
  * 格式: AND   DST，SRC
  * 操作: (DST)←(DST)∧(SRC)

* OR       ;或
  * 格式: OR   DST，SRC
  * 操作: (DST)←(DST)∨(SRC)

* NOT     ;非
  * 格式: NOT   OPR
  * 操作: $$(OPR)←(\overline{OPR})$$

* XOR     ;异或
  * 格式: XOR   DST，SRC
  * 操作: $$(DST)←(DST) \oplus (SRC)$$ 

* TEST    ;测试
  * 格式: TEST   OPR1，OPR2
  * 操作: (OPR1)∧(OPR2)
  * 注意：TEST执行AND操作, 但不保存结果,只根据其特征置标志位。

* 举例
  1. 例5.37   屏蔽AL寄存器的高四位，如AL=36H
     AND    AL，0FH  
     指令执行的结果使AL=06H
  1. 例5.38    对AL寄存器的最低两位置1，如AL=36H。
     OR    AL，03H  
     指令执行的结果使AL=37H
  1. 例5.39  对AL寄存器的最低两位取反，如AL=36H。
     XOR    AL，03H  
     指令执行的结果使AL=35H
  1. 例5.40  测试AL寄存器中的数，如果是负数则转到标号NEXT去执行。如AL=86H。
     TEST    AL，80H  
     JS      NEXT
     指令执行的结果AL=86H(不变)，我们只要注意到FLAGS标志寄存器的SF=1，所以程序转到标号NEXT去执行。

### 移位指令

* 相同点

  * 指令均是双操作数指令，指令的格式相同。

  * 以SHL为例，则格式

    1. SHL　 OPR,1

    2. SHL　 OPR,CL

  * 其中CL寄存器的值大于1。其中OPR为寄存器或内存单元，移位次数可以是1或CL寄存器，如需移位的次数大于1，则可以在该移位指令前把移位次数先送CL寄存器中。

* SHL（Shift Logical Left）　　　　　　逻辑左移

  ![image-20221104151236714](assets/image-20221104151236714.png)

  * 用来将无/有符号数乘以2

* SAL（Shift Arithmetic Left）　　　　　算术左移
  * 逻辑或算术左移时，操作结果相同，均是最低位补0，移出的最高位送CF标志位；
  * 用来将有/无符号数乘以2

* SHR（Shift Logical Right）　　　　　 逻辑右移

  ![image-20221104151330810](assets/image-20221104151330810.png)

  * 最高位补0，移出的最低位送CF标志位；

  * 用来将无符号数除以2

* SAR（Shift Arithmetic Right）　　　　 算术右移

  ![image-20221104151413189](assets/image-20221104151413189.png)

  * 此时OPR被认为是有符号数，则最高位补符号位自身，移出的最低位送CF标志位；
  * 用来将有符号数除以2

* ROL（Rotat Left）　　　　　　　　     循环左移

  ![image-20221104152450567](assets/image-20221104152450567.png)

  * OPR整体向左移一位，最高位移出，同时将其送CF标志位和最低位；

* ROR（Rotat Right）　　　　　　　　  循环右移

  ![image-20221104152350848](assets/image-20221104152350848.png)

  * OPR整体向右移一位，最低位移出，同时送CF标志位和最高位；

* RCL（Rotat Left with Carry）　　　　   带进位循环左移

  ![image-20221104152502946](assets/image-20221104152502946.png)

  * OPR整体向左移一位，此时最高位移出送CF标志位，而CF标志位原始的数值送OPR最低位；

* RCR（Rotat Right with Carry）　　　　带进位循环右移移位

  ![image-20221104152515786](assets/image-20221104152515786.png)

  * OPR整体向右移一位，此时最低位移出送CF标志位，而CF标志位原始的数值送OPR最高位。

* 举例

  1. 例5.37
     设指令执行前，AX=13H=00010011B,CF=1。
     （1）SHL　 AX,1
     若AX=00010011整体左移，最高位0送入 CF 标志位，最低位补0，结果为AX=00100110B=26H,CF=0，相当于对AX的内容乘以2。
     （2）SHR　 AX,1
     若AX=00010011整体右移，最低位1送入CF标志位，最高位补0，结果为00001001=09H,CF=1，相当于对AX的内容除以2；
     若AX=10010011，则SHR执行的结果为01001001=49H,CF=1。
     （3）SAR　 AX,1
     若AX=00010011整体右移，最低位1送入CF标志位，最高位补符号位本身，即0，结果为00001001=09H；
     若AX=10010011，则SAR执行的结果与SHR不同，结果为11001001=C9H,CF=1。
     （4）ROL　 AX,1
     若AX=00010011整体左移，最高位0同时送入 CF 标志位和最低位，结果为AX=00100110=26H,CF=0。
     （5）ROR　 AX,1
     若AX=00010011整体右移，最低位1同时送入 CF 标志位和最高位，结果为AX=10001001=89H,CF=1。
     （6）RCL　 AX,1
     若AX=00010011整体左移，最高位0送入CF标志位，而CF标志位原始的值（CF=1）送入最低位，结果为AX=00100111=27H,CF=0。
     （7）RCR　 AX,1
     若AX=00010011整体右移，最低位1送入CF标志位。
     若CF标志位原始的值（CF=1）送入最高位，结果为AX=10001001=89H,CF=1；
     若CF标志位原始的值CF=0，则结果为AX=00001001=09H,CF=1。
  
  2. 例5.42  对AX中内容实现半字交换，即交换AH和AL中的内容。
     MOV   CL， 8
     ROL   AX， CL ;循环左移
     如指令执行前，AX=1234H，指令执行后，AX=3412H。

## 串操作指令（估计不考）

## 程序转移指令

### 无条件转移指令JMP

* 定义：无条件转移到指令指定的地址去执行程序。

* 根据目标地址分类
  * 段内转移：转移的目标地址和本跳跳转指令在同一个代码段（NEAR  PTR）
  * 段间转移：转移的目标地址和本条跳转指令不在同一个代码段（FAR  PTR）
  
* 根据目标地址是否在跳转指令中直接给出分类
  * 直接转移：转移的目标地址在跳转指令中直接给出（立即数）
  * 间接转移：转移的目标地址在跳转指令中通过其他方式间接给出
  
* 四种类别两两组合
  1. 段内直接转移
     * 格式: JMP  NEAR  PTR   OPR 
     
     * 操作: IP←IP+16位位移量 
     
     * 注意
       * NEAR  PTR为目标地址OPR的属性说明，表明是一个近（段内）跳转，通常可以省略。
       * 位移量是带符号数（相对于原地址），IP的值可能减小（程序向后跳），也可能增加（程序向前跳）。
       * 程序的重新定位并不影响程序的正确执行。
       
     * 举例
       
       例5.47   关于程序的可重新定位的讨论。
       1000：JMP  P1           ；1000H是本条指令的所在偏移地址
       1002：MOV  AX， BX
       1004：MOV  DX，CX
       P1：ADD  AX， DX   ；P1是标号，其值为04H（高位为00H省略）
       如果把这个程序放在内存中的另一个位置，如下所示：
       2000：JMP  P1           ；2000H是本条指令的所在偏移地址
       2002：MOV  AX， BX
       2004：MOV  DX， CX
       P1：ADD  AX， DX    ；P1是标号，其值为04H
     
  2. 段内间接转移
  
     * 格式: JMP  WORD PTR   OPR 
  
     * 操作: IP←（EA） 
  
     * 注意：可以使用除立即数以外的任何一种寻址方式。
  
     * 举例
  
       例5.48   如果BX=2000H，DS=4000H，(42000H)=6050H，(44000H)=8090H，TABLE的偏移地址为2000H，分析下面四条指令单独执行后IP的值。
       JMP   BX                                 ；寄存器寻址，IP=BX
       JMP   WORD PTR [BX]         ；寄存器间接寻址，IP=[DS:BX]
       JMP   WORD PTR TABLE    ；直接寻址，IP=[DS:TABLE]
       JMP   TABLE[BX]                 ；寄存器相对寻址，IP=[DS:(TABLE+BX)]
       第一条指令执行后，IP=BX=2000H。
       第二条指令执行后，IP=(DS:2000H)=(40000H+2000H)=(42000H)=6050H。
       第三条指令执行后，IP=(DS:2000H)=(40000H+2000H)=(42000H)=6050H。
       第四条指令执行后，IP=(DS:4000H)=(40000H+4000H)=(44000H)=8090H。
  
  3. 段间直接转移
  
     * 格式: JMP  FAR  PTR  OPR
     * 操作
       * IP←OPR的偏移地址
       * CS←OPR所在段的段地址
  
  4. 段间间接转移
  
     * 格式: JMP  DWORD PTR   OPR 
  
     * 操作
  
       * IP←（EA）
       * CS←（EA+2）
  
     * 注意：可以使用除立即数和寄存器方式以外的任何一种寻址方式。
  
     * 举例
  
       例5.49   如果BX=2000H，DS=4000H，(42000H)=6050H，(42002H)=1234H，指出下面指令执行后IP和CS的值。
       JMP   DWORD PTR [BX]
       指令执行后，IP=(DS:2000H)=(40000H+2000H)=(42000H)=6050H；CS=(42002H)=1234H。 

### 条件转移指令

* 定义：条件转移指令根据上一条指令所设置的标志位来判别测试条件，从而决定程序转向。

* 注意
  * 通常在使用条件转移指令之前，应有一条能产生标志位的前导指令，如CMP指令。
  * 汇编指令格式中，转向地址由标号表示。
  * 所有的条件转移指令都不影响标志位。 
  
* 分类
  1. 根据单个条件标志的设置情况转移
     * 指令格式：JZ　 OPR　　　　　; 结果为零则转移
       等效指令：JE　 OPR　　　　　; 结果相等则转移
       测试条件：ZF=1,则转移。
     * 指令格式：JNZ　 OPR　　　　 ; 结果不为零则转移
       等效指令：JNE　 OPR
       测试条件：ZF=0,则转移。
     * 指令格式：JS　 OPR　　　　　; 结果为负则转移
       测试条件：SF=1,则转移。
     * 指令格式：JNS　 OPR　　　　 ; 结果为正则转移
       测试条件：SF=0,则转移。
     * 指令格式：JO　 OPR　　　　　; 结果溢出则转移
       测试条件：OF=1,则转移。
     * 指令格式：JNO　 OPR　　　　 ; 结果不溢出则转移
       测试条件：OF=0,则转移。
     * 指令格式：JC　 OPR　　　　　; 进位位为l则转移
       等效指令：JB　 OPR　　　　　; 低于(below)则转移
       等效指令：JNAE　 OPR　　　   ; 不高于(above)等于则转移
       测试条件：CF=1,则转移。
     * 指令格式：JNC　 OPR　　　　 ; 进位位为0则转移
       等效指令：JNB　 OPR　　　　  ; 不低于则转移
       等效指令：JAE　 OPR　　　　  ; 高于等于则转移
       测试条件：CF=0,则转移。
     * 指令格式：JP　　OPR　　　　 ; 奇偶位为1则转移
       等效指令：JPE　 OPR　　　　 ; 偶数个1则转移
       测试条件：PF=1,则转移。
     * 指令格式：JNP　 OPR　　　　 ; 奇偶位为0则转移
       等效指令：JPO　 OPR　　　　 ; 奇数个1则转移
       测试条件：PF=0,则转移。
     
  2. 测试CX寄存器的值为0则转移 
  
     * 指令格式：JCXZ　 OPR　　　　　 ; CX寄存器为零则转移
       测试条件：CX=0,则转移。
  
  3. 比较两个无符号数,根据结果转移(Below/Above)
  
     * 指令：JC（JB,JNAE）OPR　　　　   ; 进位位为l（低于，不高于等于）则转移
       测试条件：CF=1,则转移。
  
     * 指令：JNC（JNB,JAE）OPR　　　　; 进位位为0（不低于，高于等于）则转移
       测试条件：CF=0,则转移。
  
     * 指令：JBE（JNA）OPR　　　　　　　; 低于等于（不高于）则转移
       测试条件：CF|ZF=1,即CF与ZF的或为1,则转移。
  
     * 指令：JNBE（JA）OPR　　　　　　　; 不低于等于（高于）则转移
       测试条件：CF|ZF=0,即CF与ZF的或为0,则转移。
  
  4. 比较两个有符号数, 根据结果转移(Lower/Greater)
  
     * 指令：JL（JNGE）　OPR　　　　　　 ; 小于（不大于等于）则转移
       测试条件：SF^OF=1,即SF与OF的异或为1,则转移。
  
     * 指令：JNL（JGE）　OPR　　　　　　 ; 不小于（大于等于）则转移
       测试条件：SF^OF=0,即SF与OF的异或为0,则转移。
  
     * 指令：JLE（JNG）　OPR　　　　　　　　 ; 小于等于（不大于）则转移
       测试条件：（SF^OF）|ZF=1,即SF与OF的异或为1或者ZF=1,则转移。
  
     * 指令：JNLE（JG）　OPR　　　　　　　　 ; 不小于等于（大于）则转移
       测试条件：（SF^OF）|ZF=0,即SF与OF的异或为0且ZF=0,则转移。

### 循环指令

* LOOP                          循环

  * 指令：LOOP    OPR
    测试条件:CX ≠ 0，则循环

* LOOPZ / LOOPE        为零或相等时循环

  * 指令：LOOPZ / LOOPE    OPR
    测试条件:ZF=1  AND  CX≠0 ，则循环

* LOOPNZ / LOOPNE   不为零或不相等时循环

  * 指令：LOOPNZ / LOOPNE    OPR
    测试条件:ZF=0  AND  CX≠0 ，则循环

* 相同操作: 首先CX寄存器减1，然后根据测试条件决定是否转移。

* 例题
  例5.47
  在首地址为MESS长为19字节的字符串中查找‘空格’（20H）字符，如找到则继续执行，否则转标号NO。用循环指令实现程序的循环。
  MOV　　AL,20H
  MOV　　CX,19
  MOV　　DI,-1
  LK: INC　　DI
  CMP　 AL,MESS[DI]
  LOOPNE　LK　 ; 当CX≠0且ZF=0时跳转
  JNZ　　NO　　; 当ZF=0时跳转
  YES: …
  JMP EXIT
  NO: …
  EXIT: MOV AH,4CH
  INT 21H…
  当LOOPNE LK结束时有两种可能，即CX=0或者ZF=1，而这两种可能对应的结果是不相同的，因此在LOOPNE下方紧跟着一条JNZ的跳转指令，用以区分这两种情况。需特别注意CX=0与 ZF=1同时成立的情况，即比较的最后一个字符是相同的，所以区分以上两种情况时，需优先判断ZF=1是否成立。

### 子程序调用指令

### 中断调用指令

# 第6章 伪指令与源程序格式

## 伪指令

### 指令和伪指令的区别

|                      |                    伪指令                     |      指令       |
| :------------------: | :-------------------------------------------: | :-------------: |
| 有对应的机器语言代码 |                      否                       |       是        |
|      处理/执行       |             汇编程序处理（软件）              | cpu执行（硬件） |
|       出现位置       |               数据段代码段均可                |     代码段      |
|         功能         | 对汇编过程进行控制<br/>定义数据变量和程序结构 |  告诉CPU做什么  |

### 段定义伪指令

* 段定义
  * 伪指令格式
    segment_name    SEGMENT
        ……
    segment_name    ENDS

* ASSUME
  * 伪指令格式
    ASSUME register_name : segment_name，register_name : segment_name
  * 注意
    * 只是指定把某个段分配给哪个段寄存器，并不能把段地址装入段寄存器中
    * 所以在代码段中，还必须把段地址装入相应的段寄存器中，通常用两条MOV指令完成这一操作，但是代码段不需要这样做，它在程序初始化的时候完成。


### 程序开始和结束伪指令

* 表示源程序结束的伪指令格式：
   END [标号]

* 含义：标号指示程序开始执行的起始地址。

  e.g.：
  code segment
  start: ... 
  code ends
  end start

* 注意：只有主程序开始时的标号xxx:才能用end xxx，表示主程序的范围(类似main函数)，其它标号仅起标记程序段地址的作用。

### 数据定义与存储器单元分配伪指令

* 格式

   [变量名] 伪指令 N个操作数 [;注释]

* 变量定义：实质上就是某一个或几个存储单元。

* 变量的三种属性

  1. 段值（指明存在于哪个段中）
     变量（名字）对应存储单元的段地址

  2. 偏移值（指明段内的位置）
     变量（名字）对应存储单元的偏移地址

  3.  类型（指明每个变量占用的字节数）

     * DB(1字节)：用来定义字节，其后的每个操作数都占用1个字节。
   * DW(2字节)：用来定义字，其后的每个操作数都占用1个字。
     * DD(4字节)：用来定义双字，其后的每个操作数都占用2个字。
   * DF(6字节)：用来定义六个字节的字，其后的每个操作数都占用48位。（.286之后才支持）
     * DQ(8字节)：用来定义4个字，其后的每个操作数都占用4个字。
   * DT(10字节)：用来定义10个字节，其后的每个操作数都占用10个字节。
     * MASM6允许DB,DW,DD,DF,DQ,DT伪操作分别用BYTE,WORD,DWORD,FWORD,QWORD,TBYTE代替

* 标号与变量区别

  |                                     |               变量                |            标号            |
  | :---------------------------------: | :-------------------------------: | :------------------------: |
  |              定义位置               |         数据段代码段均可          |           代码段           |
  |                含义                 |  变量数据在内存中存放的符号地址   | 指令在内存中存放的符号地址 |
  |                组成                 |              标识符               |   标识符及后面的一个冒号   |
  | 类型属性<br/>(可以使用type指令区分) | BYTE,WORD,DWORD,FWORD,QWORD,TBYTE |          near,far          |

* 注意

  * 程序中默认的数据为十进制数。
  * 当数据第一位不是数字时，应在前面加0，避免被误认为是变量或常量。
  * 负数均为补码形式存放。
  * 字符串用‘ ’括起来。
  * ‘？’表示只分配存储单元，不存入数值。

* DUP 复制伪指令

  * 格式：count  DUP (operand, …, operand)
  * 操作：将括号中的操作数重复count次，count可以是一个表达式，其值应该是一个正数。DUP操作可嵌套。 

* 举例

  1. 例6.4  操作数为字符串。问号‘?’仅预留空间。 
     MESSAGE   DB ‘HELLO?’,?     ；问号?通常被系统置0
     		               DB ‘AB’，?
     		               DW ‘AB’        ；注意这里‘AB’(4142H)作为串常量**按字类型存放**，高位42H，低位41H

     ![image-20221105095847632](assets/image-20221105095847632.png)

  2. 例6.5用操作符复制操作数
     ARRAY   DB 2 DUP(1,3,2 DUP(4,5))

     ![image-20221105095933773](assets/image-20221105095933773.png)

### 类型属性操作符

* WORD PTR    ；字类型      

* BYTE PTR     ；字节类型 

* 注意：类型属性操作符仅是指定变量的“访问类型”，并不改变变量本身的类型。

* 举例

  例6.7  在指令中用类型属性操作符指定对内存变量的访问类型，以匹配两个操作数。 
  	OPER1    DB  3, 4
  	OPER2    DW  5678H, 9
  	┇
  	MOV   AX，WORD PTR OPER1     ；从OPER1处取一个字，使AX=0403H
  	MOV   BL, BYTE PTR OPER2     ；从OPER2处取一个字节，使BL=78H
  	MOV   BYTE PTR[DI], 0               ；常数0送到内存字节单元，使(DS*10H+DI)=00H

### THIS操作符和LABEL伪操作

* 一个变量可以定义成不同的访问类型，THIS操作符或LABEL伪操作都可以实现。

* 格式

  * THIS  type
  * name   LABEL  type

* 操作：指定一个类型为type的操作数，使该操作数的地址与下一个存储单元地址相同。

* 举例

  例6.8  把变量定义成不同访问类型，以便指令中可灵活选用。指令执行结果如图所示。  
  BUF=THIS  WORD ;BUF常量
  DAT   DB  8,9 
  OPR_B    LABEL  BYTE
  OPR_W    DW  4 DUP(2)
  ![image-20221105100946407](assets/image-20221105100946407.png)
  MOV   AX,  1234H
  MOV   OPR_B, AL
  MOV   OPR_W+2, AX
  MOV   DAT+1, AL
  MOV   BUF, AX
  表达式BUF=THIS  WORD使BUF和DAT指向同一个内存单元。
  LABE伪操作使得OPR_B和OPR_W指向同一个内存单元。
  ![image-20221105101000470](assets/image-20221105101000470.png)

### 表达式赋值伪指令“EQU” 和 “=”

* 可以用赋值伪操作给表达式赋予一个常量或名字。格式如下：
  Expression_name  EQU  Expression
  Expression_name  =  Expression
* 注意

  * 表达式中的变量或标号，必须先定义后引用。
  * EQU伪操作中的表达式名是不允许重复定义的，而“＝”伪操作则允许重复定义。 
* 举例
  VALUE=53
  VALUE=VALUE+89
  如果把上面的两条赋值伪指令的“=”改成“EQU”，则为重复定义表达式名VALUE，是不允许的。

### 汇编地址计数器$与定位伪指令

1. 地址计数器 $

   * 定义

     * 地址计数器是一个16位的变量，用\$表示
     * 开始汇编或在每一段开始时，将地址计数器初始化为零。
     * 当在指令中用到$时，它只代表此指令的首地址，而与$本身无关。
     * 当\$用在伪操作的参数字段时，它所表示的是地址计数器的当前值。
     * 每一段的开始，地址计数器初始化为零，接着每处理一条指令，地址计数器就增加一个值，此值为该指令所需要的字节数，以安排下条指令的存放位置。

   * 举例

     1. array dw 1,2,\$+4,3,4,\$+4，array分配的偏移地址 为0074。
         [0074]  01,00 ,  02,00,  7C,00，03,00,  04,00, 82,00
                                                 0078+4                          007E+4
        注：ARRAY数组中的两个\$+4得到的结果是不同的，这是由于\$的值在不断变化。

     2. 例6.9 考察\$的作用，假定\$初值=0，数据在内存中的存放如图所示。
        ARRAY　 DW 3,\$+7,7
        COU=\$
        NEW　　 DW COU
        
        ![image-20221105102939699](assets/image-20221105102939699.png)

2. ORG 伪操作 

   * 定义：用来设置当前地址计数器的值。

   * 格式：ORG  constant或expression

   * 操作：如常数表达式的值为n，则该操作指示下一个字节的存放地址为n。

   * 举例

     例6.10  考察ORG伪操作,数据在内存中的存放如图所示。 
     ORG  0
     DB   3
     ORG  4
     BUFF   DB  6
     ORG    $+6
     VAL    DB  9

     ![image-20221105104850913](assets/image-20221105104850913.png)

3. 其它的估计不考

## 语句格式

### 指令和有关数据定义的伪指令格式

[name]　 operation　 0perand　[; comment]
[名字]　　　 操作　　操作数　  [; 注释]
上面带方括号的两项是可选项。各项之间必须用‘空格’隔开。

* 名字项
  * 定义：是一个符号，可以是指令的**标号**，也可以是**变量名**。
  * 组成：字母、数字和专用字符（?,·,@,_,$）
  * 属性
    1. 段值（指明存在于哪个段中）
       名字项对应存储段的段地址
    2. 偏移值（指明段内的位置）
       名字项在存储段内的偏移地址
    3. 类型（指明名字项的类型属性）
       标号的类型可以是NEAR和FAR两种
       变量的类型可以是 BYTE,WORD,DWORD,FWORD,QWORD,TBYTE
    
  * 注意
    * 除数字外，所有字符都可以放在源语句的第一个位置。
    * 名字中如果用到·，则必须是第一个字符。
    * 不能与保留字相同。
    * 不能重复定义。
  
* 操作项
  * 定义：是一个操作码的助记符，它可以是**指令**、**伪指令**或**宏指令名**。
  
* 操作数项
  * 定义：由一个或多个表达式组成，它提供该操作所要求的操作数或相关信息。
  
  * 注意
    * 表达式在**汇编阶段**起作用，只有正确的表达式才能通过汇编。
  
  * 分类
  
    * 算术操作符
  
      * 算术运算符主要有+、－、*、/、MOD。
  
        * MOD也称为取模，它得到除法之后的余数。
        * 减法运算可用于段内两个操作数地址（以变量名表示）的运算，其结果是一个常数，表示这两个变量之间相距的字节数。
  
      * 注意：算术操作符在表达式中的使用，其结果必须有明确的物理意义时才是有效的
  
      * 举例
        例6.12  算术操作符的使用，设有如下定义：
        ORG 0
        VAL=4
        DA1  DW  6，2，9，3
        DA2  DW  15，17，24
        COU=$-DA2
        VAL是常数，无需确定它的位置就可以使用。
        DA1和DA2是变量的符号地址，它们在内存中有确定的位置，我们只能根据它们的地址才能访问。
	      MOV    AX，DA1\*4          ;错，地址乘或除，没有意义
	      MOV    AX，DA1\*DA2        ;错，地址乘或除，没有意义
        MOV    AX，DA1+DA2        ；错，地址相加，没有意义
	      MOV    AX，BX+VAL          ；错，BX+VAL须用指令实现
	      MOV    AX，[BX+VAL]        ；地址表达式，汇编成MOV  AX， [BX+4]，寄存器相对寻址
	      MOV    AX，DA1+VAL        ；地址表达式，汇编成MOV  AX，[4]，直接寻址
	      MOV    AX，[DA1+VAL]      ；地址表达式，汇编成MOV  AX，[4]
	      MOV    AX，VAL\*4/2           ；数字表达式，汇编成MOV  AX，8，立即寻址
        MOV    AX，[VAL\*4/2]         ；数字表达式，汇编成MOV  AX，8（masm中若不加段超越前缀，[数字]外的中括号会被去除）
	      MOV    CX，(DA2-DA1)/2    ；得到DA1区数据个数，汇编成MOV  CX，4
        MOV    BX，COU                 ；得到DA2区的字节数， 汇编成MOV  BX，6
  
    * 逻辑与移位操作符
  
      * 逻辑操作符：AND,  OR,  NOT, XOR。
      * 移位操作符：SHL和SHR。
      * 格式：expression  操作符 number
      * 注意
        * 逻辑与移位操作符都是**按位**进行的。
        * 逻辑与移位操作符都只能用于**数字表达式**中。
      * 举例
        1. 例6.13  逻辑操作符的使用
           ARY  DW   8
           VAL=4
           MOV   AX，BX AND 0FFH    ；错，BX AND VAL须用指令实现
           MOV   AX，ARY AND 0FFH  ；错，ARY AND VAL须用指令实现
           MOV   AX，VAL AND 0F0H   ；汇编成MOV  AX，0
           AND   AX，VAL OR 0F0H      ；汇编成AND  AX，0F4H
        2. 例6.14  移位操作符的使用
           ARY  DW   8
           VAL=4
           MOV    AX，BX SHL 2      ；错，BX 左移须用指令实现
           MOV    AX，ARY SHL 2    ；错，ARY 左移须用指令实现
           MOV    AX，VAL SHL 2    ；汇编成MOV  AX，10H
           MOV    AX，8  SHL 2        ；汇编成MOV  AX，20H
           MOV    AX，VAL SHL 15  ；汇编成MOV  AX，00H
  
    * 关系操作符
  
      * 关系操作符用来对两个操作数的大小关系作出判断。
  
        * EQ（相等）
        * NE（不相等）
        * LT（小于） 
        * LE（小于等于）
        * GT（大于）
        * GE（大于等于）
  
      * 注意
  
        * 关系操作符的两个操作数必须都是**数字**，或是**同一段**内的两个存储器**地址**。
        * 计算结果为逻辑值，结果为真表示为0FFFFH，结果为假表示为0。
      
    * 举例
      
      例6.15  关系操作符的使用
        VAL=4
        MOV    AX，BX  GT 2     ；错，BX 是否大于2须用指令实现判断
        MOV    AX，VAL GE 2    ；汇编成MOV  AX，0FFFFH
        MOV    AX，8  LE VAL    ；汇编成MOV  AX，0
        MOV    AX，-3 GE 5         ；汇编成MOV  AX，0
        MOV    AX，255 GE 5      ；汇编成MOV  AX，0FFFFH
    
  * 数值回送操作符
  
    * TYPE
  
      * 格式：TYPE  expression
      * 操作
        * 表达式为变量，则汇编程序回送该变量的以字节数表示的类型。 
          DB        回送1           DW       回送2
          DD        回送4           DF         回送6
          DQ        回送8           DT         回送10
        * 表达式为标号，则汇编程序回送代表该标号类型的数值。
          NEAR    回送-1
          FAR       回送-2
        * 表达式为常数则回送0。 
  
    * LENGTH
  
      * 格式： LENGTH  variable 
      * 操作
        * 若变量用DUP定义，则返回**总变量数**，否则为1。
        * 嵌套的DUP不计。所以，对于使用嵌套的DUP复制的数据不能据此得到正确的总变量数。
  
    * SIZE
  
      * 格式：SIZE  variable 
      * 操作
        * SIZE=TYPE*LENGTH
        * 若变量用DUP定义，则返回**总字节数**，否则为单个变量的字节数。
        * 嵌套的DUP不计，所以，对于使用嵌套的DUP复制的数据不能据此得到正确的总字节数。
  
    * OFFSET
  
      * 格式：OFFSET    variable或label
      * 操作：回送变量或标号的偏移地址（16位）。
  
    * SEG
  
      * 格式：SEG    variable或label
      * 操作：回送变量或标号的段地址（16位）。 
  
    * 举例
  
      例6.16  数值回送操作符的使用
      设有如下定义：
      ORG  0
      VAL=4
      ARR   DW  4  DUP(3)
      BUF   DW  4  DUP( 4 DUP(3))
      DAT   DW  15，17，24
      STR   DB  ‘ABCDEF’
      汇编程序对下面的指令汇编结果为：
      MOV    AX，TYPE ARR               ；汇编成MOV  AX，2
      MOV    AX，LENGTH  ARR         ；汇编成MOV  AX，4
      MOV    AX，LENGTH  BUF         ；汇编成MOV  AX，4
	MOV    AX，LENGTH  DAT         ；汇编成MOV  AX，1
	MOV    AX，SIZE  ARR                ；汇编成MOV  AX，8
	MOV    AX，SIZE  BUF                ；汇编成MOV  AX，8（不是32）
      MOV    AX，SIZE  DAT                ；汇编成MOV  AX，2
	MOV    AL，SIZE  STR                ；汇编成MOV  AX，1
	MOV    AX，OFFSET  ARR         ；汇编成MOV  AX，0
	MOV    BX，SEG  ARR                ；汇编成MOV  BX，(DS)
	
* 注释项
  * 定义：用来说明程序或语句的功能。

# 第7章 分支与循环程序设计

## 程序设计的一般步骤:

1. 分析问题，确定算法和数据结构。
2. 根据算法绘制程序流程图。
3. 根据流程图编写程序。
4. 上机调试程序。

## 程序结构分类

有顺序, 分支,循环,子程序4种

## 分支程序设计

### 分支程序结构

### 单分支程序

* 题目

例7.1   双字长数存放在DX和AX寄存器中(高位在DX)，求该数的绝对值(用16位指令)。 

* 算法分析

   1. 双字长数高字在DX中，低字在AX中；
   2. 判该数的正负，为正数（最高位为0），该数不处理；为负数，就对该数求补（即反码加1）。

* 图解

  ![image-20221105121329076](assets/image-20221105121329076.png)

* 代码

```assembly
code  segment
	assume  cs:code
start:
    test   dx,8000h         ;测试数的正负
    jz     exit             ;不为负数就退出
    not    ax
    not    dx
    add    ax,1
    adc    dx,0
exit:  
    mov    ah,4ch
    int    21h
code  ends
	end    start
```

### 复合分支程序

* 题目

  例7.2   从键盘输入一位十六进制数，并将其转换为十进制数输出显示。

  ![image-20221105121926186](assets/image-20221105121926186.png)

* 算法分析：从键盘输入一个十六进制数，有以下四种情况
  
     1. 为数字0～9（ASCII码30～39H），无需处理，直接输出；
     2. 为大写字母A～F（ASCII码41～46H），先输出31H（1），再输出该数ASCII码-11H；
     3. 为小写字母a～f（ASCII码61～66H），先输出31H，再输出该数ASCII码-31H；
     4. 该数不为0～9、A～F、a～f，是非法字符，应退出程序或输出错误信息。
     
* 图解

   ![image-20221105121958270](assets/image-20221105121958270.png)

* 代码

  ```assembly
  code segment
  	assume cs:code
  start:  
      mov   ah,1                ;键盘输入
      int   21h
      
      cmp   al,30h           
      jl    exit                        ;非法输入
      
      cmp   al,39h
      jle   dig                        ;输入是数字0～9
      cmp   al,41h
      jl    exit                         ;非法输入
      
      cmp   al,46h 
      jle   print                      ;输入是大写A～F
      
      cmp   al,61h
      jl    exit                         ;非法输入
  
      cmp   al,66h
      jg    exit                     ;非法输入
      
      sub al,31h            
      jmp   out1                  ;输入是小写a～f
  print: sub   al,11h           
  out1: mov   dl,31h             ;输出字符1
      mov   ah,2
      push  ax                     ;暂存AX
      int   21h                      ;int指令改写了AX
      pop   ax                      ;恢复AX
  dig: mov dl,al                ;输出个位
      mov   ah,2
      int   21h
  exit: mov ah,4ch            ;程序终止并退出  
  	int 21h  
  code ends
  	end start
  ```

### 多分支程序

* 题目

  例7.3  根据键盘输入的一位数字(1～4)，使程序转移到4个不同的分支中去，以显示键盘输入的数字。

* 算法分析

  1. 从键盘输入一个数1～4
  2. 建立一个分支向量表branch ，集中存放四个分支的偏移地址；
  3. 每个偏移地址位16位，占用2个单元；
  4. 四个分支的偏移地址在转移地址表的地址是：转移地址表首址+输入数字（0～3）×2；
  5. 用间接寻址方式转向对应分支。

* 图解

  ![image-20221105123551700](assets/image-20221105123551700.png)

* 代码

  ```assembly
  code    segment
  	assume  cs:code,ds:code
  start:    
      mov   ax,code           ;ds=cs
      mov   ds,ax
      mov   ah,7             ;键盘输入无回显
      int   21h
      cmp   al,31h           
      jl    exit                     ;非法输入
      cmp   al,34h
      jg    exit                    ;非法输入
      mov   dl,al             ;放入dl,待显示
  
      mov   bl,al
      sub   bl,31h             ;转换ascii码为数值
      shl   bl,1                   ;(bl)×2,指向分支向量表中某地址
      mov   bh,0
      jmp   branch[bx]        ;转向分支 
  r1:    mov   ah,2
      int   21h                       ;显示键盘输入的数字
      jmp   exit
  r2:    mov   ah,2
      int   21h
      jmp   exit
  r3:    mov   ah,2
      int   21h
      jmp   exit
  r4:    mov   ah,2
      int   21h
      jmp   exit
  exit: mov   ah,4ch           ;程序终止并退出
      int   21h
      
  branch  ;变量
  	dw    r1
      dw    r2
      dw    r3
      dw    r4
  code    ends
  	end   start
  ```

## 循环程序设计

### 循环程序结构

### 计数循环程序

* 题目

  例7.4  把BX中的二进制数用十六进制显示.（设BX=123AH）

* 算法分析

  1. 屏幕显示字符用2号DOS功能调用，DL=输出字符。 
  2. BX寄存器每4位表示一位十六进制数位：BX=123AH=0001 0010 0011 1010
  3. BX=1         2               3                A          H,
     1-->31H     2-->32H   3-->33H    A-->41H 
  4. BX从左到右循环移位，每移4位，就把要显示的4位二进制位移到最右边。
  5. 取出最右边的4位，加上30H，转换成8位ASCII字符码。
  6. 当8位二进制数大于39H时，应再加上7。（41H-40H=7H）

* 图解

  ![image-20221105124755856](assets/image-20221105124755856.png)

* 代码

  ```assembly
  code    segment
  	assume  cs:code
  start:  mov   cx,4
  shift:
  	rol   bx,1             ;连续循环左移4位
      rol   bx,1
      rol   bx,1
      rol   bx,1
      mov   al,bl
      and   al,0fh           		;取最右4位
      add   al,30h           	;转为ascii
      cmp   al,39h
      jle   dig              	 ;是0～9则转dig
      
      add   al,7            	 ;是A～F
   dig: mov   dl,al
       mov   ah,2
       int   21h
       loop  shift
       
       mov   ah,4ch
       int   21h
  code    ends
  	end   start
  ```

### 条件循环程序

* 题目
  例7.5 从键盘输入8位二进制数作为逻辑尺。再输入一个英文字母，根据逻辑尺当前的最高位标志显示输出该字母的相邻字符，标志位为0则显示其前趋字符，标志位为1则显示其后继字符。显示相邻字符后，逻辑尺循环左移一位，再接收下一个字母的输入，并依据逻辑尺显示相邻字符，直到回车键结束程序。

* 算法分析

    1. 循环次数已知，但每次循环所做的操作不同； 
    2. 设置逻辑尺，循环中依据逻辑尺中的标志位选择操作。

* 图解

    ![image-20221105125814251](assets/image-20221105125814251.png)

* 代码

    ```assembly
    code    segment
        assume  cs:code
    start:    
    	mov   bx,0            		 ;初始化
        mov   cx,8
    inlog: 
    	mov   ah,1            	 ;键盘输入0/1逻辑尺
        int   21h
        cmp   al,30h           
        jb    exit             		 ;非法输入
        cmp   al,31h
        ja    exit             		 ;非法输入
        sub   al,30h       		 ;输入是0/1
        shl   bl,1					;逻辑左移
        add   bl,al
        loop  inlog
        
        mov   ah,2
        mov   dl,10            ;输出换行
        int   21h
    inchr: 
    	mov   ah,1             ;键盘输入字母
        int   21h
        cmp   al,13 
        je    exit       	       ;回车键
        
        mov   dl,al
        rol   bl,1			;循环左移，OPR整体向左移一位，最高位移出，同时将其送CF标志位和最低位
        jnc   k30              	 ;是0 则转k30	
        
        inc   dl
        jmp   putc
    k30: dec   dl
    putc: mov   ah,2
        int   21h
        jmp   inchr
    exit: mov   ah,4ch          	 ;程序终止并退出  
    	int   21h
    code    ends
    	end   start
    ```

### 条件计数循环程序

* 题目

  例7.6  设置键盘缓冲区为16个字节，从键盘输入一串字符，然后再从键盘输入一个单个字符，查找这个字符是否在字符串中出现，如果找到，显示该字符串，否则显示‘NOT FOUND’。

* 算法分析

      1. 使用DOS系统功能调用10号功能实现键盘缓冲区输入，
      2. 使用1号功能实现单个字符输入，
      3. 使用9号功能实现字符串显示输 出。
      4. 程序采用循环结构实现查找，最大计数值为实际输入的字符个数。 

* 图解

  ![image-20221105132114989](assets/image-20221105132114989.png)

* 代码

  ```assembly
  data    segment
      buffer   db   16,?,16 dup(?),13,10,'$' ;13回车10换行
      inputs   db   13,10,'input string:$'
      getc     db   13,10,'input char:$'
      output   db   13,10,'not found$'
  data    ends
  code    segment
  	assume  cs:code,ds:data
  start:  	mov   ax,data             ;ds赋值
      mov   ds,ax
      lea   dx,inputs           ;信息提示输入串
      mov   ah,9
      int   21h 
      lea   dx,buffer           ;键盘输入串到缓冲区
      mov   ah,10
      int   21h	
      lea   dx,getc            	 ;信息提示输入字符
      mov   ah,9
      int   21h
      mov   ah,1              	 ;输入字符到al
      int   21h
      mov   bl,al              	 ;保存到bl
      lea   di,buffer+1     	 ;di作为指针指向缓冲区
      mov   cl,buffer+1          ;cx设置计数值
      mov   ch,0  
  seek:
  	inc   di                      
      cmp   bl,[di]
      loopne   seek             	 ;未完且没找到,转seek继续循环
  
      jne   nof                     	 ;没找到,转nof输出‘not found’
      mov   dl,10             	 ;输出换行	
      mov   ah,2                   
      int   21h
      lea   dx,buffer+2             ;指向缓冲区,输出字符串
      mov   ah,9                   
      int   21h
      jmp   exit 
  nof: lea   dx,output
      mov   ah,9                   
      int   21h
  exit: mov   ah,4ch
      int   21h
  code    ends
  	end   start
  ```

  

### 多重循环程序

* 题目

  例7.7  显示输出20H～7EH的ASCII码字符表，每行16个字符。

* 算法分析
      1. 20H～7EH的ASCII字符共有95个，需6行显示。
      2. 程序需两重循环，内循环输出每行16个字符，循环计数初值为16，程序终止条件是显示最后一个字符。

* 代码

  ```assembly
  code    segment
      assume  cs:code
      ;常量
      k=16
      first=20h
      last=7eh
  start:  mov   dx,first              ;从第一个开始
  a10:    mov   cx,k                ;每行16个
  a20:    mov   ah,2
      int   21h
      cmp   dl,last              ;是最后一个则退出
      je    exit
      
      push  dx                        ;暂存dx
      mov   dl,20h               ;空2格
      int   21h
      int   21h
      
      pop   dx                         ;恢复dx
      add   dx,1
      loop  a20                       ;进入内循环
      
      push  dx                        ;暂存dx
  
      mov   dl,13               ;回车
      int   21h
      mov   dl,10               ;换行
      int   21h
      
      pop   dx                      ;恢复dx
      loop  a10                    ;进入外循环
  exit: 
  	mov   ah,4ch
      int   21h
  code    ends
  	end   start
  ```

